from dataclasses import astuple, dataclass

from . import math
from . import curveParameter

@dataclass
class Point:
    """
    Point in elliptic Curve.
    Attributes:
        x: int
        y: int
    """
    x: int
    y: int
    def __init__(self, x = None, y = None):
        self.x = x
        self.y = y

@dataclass
class EllipticCurve:
    """
    Let a eliptic curve defined by y^2 = x^3 +ax+b defined over Fp : E[Fp]
    generated by basepoint <P> with an order of #E[Fp]
        p: EC defined over Fp
        a: constant for y^2 = x^3+ax+b
        b: constant for y^2 = x^3+ax+b
        P: base point
        n: order of [h]E[Fp] = <G> = [h]<P>
        h: G is a element h-torsion of E[Fp]

    Attributes:
        p: int
        a: int
        b: int
        n: int
        h: int
        P: Point {x, y}
    
    #TO_DO_LIST: fill the description above  
    """
    p: int
    a: int
    b: int
    P: Point
    n: int
    h: int
    
    def __init__(self, curveStd: str):
        """
        create new Elliptic Curve based on curve standard:
        bn158, toyF13, typeG, p224, sect163k1, NISTP192
        """
        EC = curveParameter.curveStandard[curveStd]
        self.p = EC.p
        self.a = EC.a
        self.b = EC.b
        self.P = Point(EC.Px, EC.Py)
        self.n = EC.n
        self.h = EC.h        
    
    def __check_anti_singular(self):
        """
        """
        anti_singular = ((4*(self.a**3) + 27*(self.b**2)) != 0)
        return anti_singular

    def __addition_different_point(self, point1: Point, point2: Point):
        """
        Addition two different point in Elliptic Curve.
        """
        resultPoint = Point()

        dividend = point1.y - point2.y
        divisor = point1.x - point2.x
        
        if divisor != 0:
            divisorInv = math.multiInv_ECC(self.p, (divisor % self.p))
            m = (dividend * divisorInv) % self.p
            resultPoint.x = ((m * m) - point1.x - point2.x) % self.p
            resultPoint.y = (m * (point1.x - resultPoint.x) - point1.y) % self.p

        return resultPoint

    def __addition_same_point(self, point1: Point):
        """
        Addition the same point in Elliptic Curve
        """
        resultPoint = Point()

        dividend = (3 * (point1.x * point1.x) + self.a)
        divisor = 2 * point1.y

        if divisor != 0:
            divisorInv = math.multiInv_ECC(self.p, (divisor % self.p))
            m = (dividend * divisorInv) % self.p
            resultPoint.x = ((m * m) - (2 * point1.x)) % self.p
            resultPoint.y = (m * (point1.x - resultPoint.x) - point1.y) % self.p

        return resultPoint

    def subtraction_point(self, point1: Point, point2: Point):
        """
        Subtract point1 by point2 in Elliptic Curve
        """
        point2.y = self.p - point2.y

        if (point1.x == point2.x and point1.y == point2.y):
            return self.__addition_same_point(point1)
        else:
            return self.__addition_different_point(point1, point2)

    def addition_point(self, point1: Point, point2: Point):
        """
        Add point1 and point2 in Elliptic Curve
        """
        if point1.x == point2.x and point1.y == point2.y:
            return self.__addition_same_point(point1)
        else:
            return self.__addition_different_point(point1, point2)
        
    def multiplication_point(self, n, point: Point):
        """
        Multiply point by n in Elliptic Curve
        """
        n_binary = "{0:b}".format(n)

        resultPoint = point
        for i in range(1, len(n_binary)):
            if (n_binary[i] == '1'):
                resultPoint = self.__addition_same_point(resultPoint)
                resultPoint = self.addition_point(resultPoint, point)
            else:
                resultPoint = self.__addition_same_point(resultPoint)
        return resultPoint

    def __get_corresponding_y(self, x):
        y_pow2 = (pow(x,3) + (self.a*x) + self.b)
        y1, y2 = math.calculate_square_root_modular(y_pow2, self.p)
        return y1, y2

    def pointCompression(self, P: Point):
        """
        get point x coordinate from the point
        """
        if (P.y % 2 == 0): # y is even
            compressed = str(int(P.x)) + str(0)
        else:
            compressed = str(int(P.x)) + str(1)
        return compressed

    def pointDecompression(self, Px):
        """
        return point of ECC from the x coordinate
        """
        leastBit = int(Px[-1])
        xVal = int(Px[:-1])
        Py = self.__get_corresponding_y(xVal)
        if (Py[0]%2 == leastBit):
            yVal = Py[0]
        else:
            yVal = Py[1]

        return Point(xVal, yVal)

    